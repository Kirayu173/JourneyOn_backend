# JourneyOn 智能体开发指南

## 1. 系统总体架构

JourneyOn 后端采用 FastAPI 作为对外接口层，通过注册多个业务路由并注入统一的生命周期、日志和中间件，构成 API → Service → Provider → Agent 的分层结构。
Trip、Stage、Task、Conversation、KBEntry 等核心领域对象在 SQLAlchemy 模型中定义，为所有业务层提供统一的数据契约。

推荐的分层关系：

<pre class="overflow-visible!" data-start="613" data-end="2649"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre!"><span><span>┌────────────────────────────┐
│         </span><span>Fast</span><span>API </span><span>API</span><span>        │  ← 请求入口、身份校验、会话持久化</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>32</span><span> line_range_end=</span><span>205</span><span> path=app/api/routes/agent.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/api/routes/agent.py#L32-L205"</span><span>}
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│          </span><span>Services</span><span>          │  ← </span><span>Trip</span><span>/</span><span>Stage</span><span>/</span><span>Task</span><span>/</span><span>KB</span><span>/</span><span>Conversation</span><span> 等业务封装</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>12</span><span> line_range_end=</span><span>166</span><span> path=app/services/trip_service.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/services/trip_service.py#L12-L166"</span><span>}</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>17</span><span> line_range_end=</span><span>116</span><span> path=app/services/stage_service.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/services/stage_service.py#L17-L116"</span><span>}
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│          </span><span>Providers</span><span>         │  ← </span><span>LLM</span><span>、工具调用、外部 </span><span>API</span><span> 封装</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>42</span><span> line_range_end=</span><span>195</span><span> path=app/llm/client.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/llm/client.py#L42-L195"</span><span>}</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>61</span><span> line_range_end=</span><span>99</span><span> path=app/providers/tools/standard.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/providers/tools/standard.py#L61-L99"</span><span>}
└────────────┬───────────────┘
             │
┌────────────▼───────────────┐
│     </span><span>LangGraph</span><span></span><span>Agents</span><span>       │  ← 阶段子图、上下文、stage orchestration</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>17</span><span> line_range_end=</span><span>68</span><span> path=app/agents/graph.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/agents/graph.py#L17-L68"</span><span>}</span><span>:codex-file-citation</span><span>[codex-file-citation]{line_range_start=</span><span>10</span><span> line_range_end=</span><span>86</span><span> path=app/agents/base_agent.py git_url=</span><span>"https://github.com/Kirayu173/JourneyOn_backend/blob/main/app/agents/base_agent.py#L10-L86"</span><span>}
└────────────────────────────┘
</span></span></code></div></div></pre>

**开发建议**

* 保持 API → Service → Provider 的依赖顺序，避免跨层直接访问模型。
* 将所有领域逻辑抽离到服务层，Agent 负责 orchestrator/prompt 与工具调用即可。

---

## 2. 智能体整体设计

### 线性 LangGraph 流程

AgentOrchestratorGraph 将行程划分为 PreTrip → OnTrip → PostTrip 的线性节点，并根据 `should_proceed/next_stage` 决定是否前进。
每个节点通过 `AgentContext` 接收用户消息、阶段、行程 ID 等上下文，以 `AgentRunResult` 返回回复、数据与阶段推进意愿。

### Orchestrator 职责

Orchestrator 接收 API 层请求，校验 stage、加载 trip、检测用户是否明确提出“进入下一阶段”，再执行图计算并在必要时调用 `advance_stage` 更新数据库。
阶段推进遵循 StageService 的顺序校验与状态更新逻辑，确保 pre→on→post 单向前进并同步 `TripStage` 记录。

### 输入输出与数据来源

* 输入：用户消息、trip/stage 标识、可选客户端上下文。
* 输出：阶段回复、stage history、transition 信息、最新 trip 状态。
* 数据来源：Trip/Stage/Task/KB 通过服务层读取；Conversation Service 负责会话持久化。
* 工具调用：在 Stage agent 内按需触发 Provider；当前示例使用 mock provider，可在真实环境替换或扩展。
* LLM/流式输出：StreamingAgentSession 生成结构化事件，最终汇总回复并附带 usage 元数据。

**开发建议**

* 在 AgentContext 中预留扩展字段（`extra`）可传递跨节点缓存。
* 所有阶段推进必须通过 `advance_stage`，避免跳过状态验证。

---

## 3. 模块分布指南

| 模块类型 | 放置目录                                      | 主要职责                                                                               |
| -------- | --------------------------------------------- | -------------------------------------------------------------------------------------- |
| Agent    | `app/agents/<stage>_agent/graph.py`         | 处理阶段内决策、生成回复、设置 `should_proceed/next_stage`。                         |
| Tool     | `app/providers/tools/<name>_tool.py`        | 基于 `StandardStructuredTool` 实现 LangGraph 兼容工具，封装外部 API 调用与输入校验。 |
| Service  | `app/services/*.py`                         | 聚合数据库操作与领域逻辑（行程、阶段、任务、知识库等）。                               |
| LLM      | `app/llm/client.py`                         | 统一对接 Ollama/Zhipu，提供重试、流式输出、Embedding 接口。                            |
| Memory   | `app/services/kb_service.py` + Redis/Qdrant | 管理 KB CRUD、向量化、Qdrant 检索和 Rerank 流程。                                      |
| API      | `app/api/routes/*.py`                       | 请求验证、认证、与 Orchestrator/Service 对接并返回统一 Envelope。                      |

**开发建议**

* 每新增模块需附带 `__init__.py` 维护包结构，方便自动导入或依赖注入。

---

## 4. 智能体功能定义

### PreTrip Agent

* 目标：收集行前需求、制定准备事项，并在用户确认后推进到 OnTrip。
* 输入：用户消息、Trip/Stage、客户端上下文、历史会话（可通过 Conversation Service 拉取）。
* 输出：行前建议、`status`（等待确认/准备完成）、`should_proceed` 标记与下一阶段指向 on。
* 工具：天气、航班、酒店查询等，可通过 ToolRegistry 注入 mock 或真实实现。
* 状态推进：Orchestrator 检测用户确认关键词后，将 `advance_stage=True` 传入 agent 并最终调用 StageService 更新阶段。

### OnTrip Agent

* 目标：提供行中调整、交通与餐饮建议，必要时生成任务/行程条目，待用户确认后进入 PostTrip。
* 输入输出：与 PreTrip 类似，但 `status` 为 `in_progress`，确认后 `next_stage=post`。
* 工具与服务：可写任务到 TaskService、生成行程，通过 Itinerary/Task API 返回给前端。
* 阶段推进：同样通过 Orchestrator + StageService 完成行程状态推进。

### PostTrip Agent

* 目标：行后总结、收集反馈、归档知识，输出最终报告或新旅程建议，不再推进阶段。
* 输出：`status=completed`，`should_proceed=False`，提示可发起新旅程。
* 数据沉淀：可写入 KBEntry、任务完成状态、汇总报告。

**开发建议**

* 各阶段应统一返回结构化 JSON，方便前端解析并驱动 UI。
* 建议在 `context.extra` 中缓存工具结果，避免重复调用。

---

## 5. 工具体系说明

### 标准工具骨架

`StandardStructuredTool` 提供统一的 name/description/schema，并兼容 langchain-core 的 StructuredTool；未安装 langchain 时自动回退至轻量实现。

### 新增工具流程

1. 在 `app/providers/tools` 创建 `<feature>_tool.py`，继承 `StandardStructuredTool`，实现 `_run/_arun`。
2. 使用 Pydantic `args_schema` 定义输入格式，返回结构化字典，供 Agent 直接消费。
3. 在阶段 Agent 初始化时注册工具列表，或通过 ToolRegistry 自动扫描。
4. 结合 Service 层（如 `TripService`、`TaskService`）持久化结果。

### 现有工具示例

Mock provider 提供任务、行程、天气、酒店、航班、POI 的示例实现，便于在无外部依赖时调试。

**命名规范**

* 工具类命名：`<Domain><Action>Tool`。
* 文件命名：`<domain>_<action>_tool.py`。
* 注册时需在 Agent 内维护 `tools` 列表或统一注册器，确保 orchestrator 可引用。

**开发建议**

* 在工具返回结构中包含原始调用参数与元信息（如成本、数据源），方便审计或缓存。
* 对需要异步调用的外部服务优先实现 `coroutine` 并使用 `_StructuredTool.ainvoke`。

---

## 6. 智能体逻辑放置规范

1. **Prompt 模板** ：在各阶段目录下创建 `prompts/`（如 `app/agents/pre_agent/prompts/collect_requirements.md`），由 Agent 读取并注入 LLM。
2. **工具编排** ：在阶段 Agent 中定义 `self.tools` 或 `resolve_tools()` 方法，调用 `StandardStructuredTool` 派生类，返回结构化结果供 `AgentRunResult.data` 使用。
3. **状态检查** ：Orchestrator 中 `_should_advance` 实现关键词判断；阶段 Agent 可补充更细致的确认逻辑。
4. **输出解析** ：将 LLM 输出通过 Pydantic Schema 解析后写入 `AgentRunResult`，保持与 StageService 的契约一致。
5. **Orchestrator 注册** ：若新增阶段或替换子图，在 `AgentOrchestratorGraph.__init__` 中注册新节点并更新 `stage_order`；同时调整 StageService 的顺序常量，确保推进逻辑一致。

**开发建议**

* 为每个阶段的 prompt/工具/解析建立子模块，遵循 `graph.py` → `prompts/` → `tools/` → `parsers.py` 的组织方式，利于多人协作。

---

## 7. 数据与知识库对接

### KB 管线

* CRUD：通过 `create_kb_entry/get_kb_entries/update/delete` 提供行程私有知识库管理，并校验 trip ownership。
* 向量化：`process_entry_embedding` 根据配置调用 `EmbeddingService`，生成向量写入 Qdrant。
* Qdrant：`QdrantService` 负责 collection 初始化、upsert、search，支持并发锁与距离配置。
* Rerank：可选的 `RerankService` 对搜索结果打分，提升召回质量。

### 会话与记忆

* ConversationService 保存每次对话并可按阶段读取历史，用于 Agent 构造上下文。
* Redis/Qdrant 可结合使用：Redis 存储短期上下文缓存，Qdrant 存储长期知识。

### 写入/检索时机建议

* 新信息（用户偏好、工具结果）写入 KB/Task/Itinerary 时机：Agent 完成结构化总结后调用相应 Service。
* 回复前：从 KB 和 Conversation 获取上下文，结合 LLM 生成答案。
* 阶段结束：触发任务完成、知识总结等持久化。

**开发建议**

* 对于高价值信息（预算、酒店预订），优先写入 Trip.agent_context 或 KB，并在 PostTrip 阶段统一回顾。
* 使用 EmbeddingService 时注意并发限制（`EMBEDDING_CONCURRENCY`），避免阻塞请求。

---

## 8. 开发流程与测试建议

1. **单元测试结构** ：已有 `tests/test_agent_linear_flow.py` 覆盖阶段推进流程，可仿照编写针对任务、行程、KB 等场景的测试用例。
2. **端到端模拟** ：使用 FastAPI TestClient 调用 `/api/agent/chat`、`/api/trips` 等接口模拟完整会话，确保阶段切换与数据落库一致。
3. **工具/服务测试** ：为每个工具与 Service 编写独立测试，校验外部 API mock 行为与数据持久化逻辑。
4. **pytest** ：在根目录运行 `pytest`，确保所有用例通过（建议结合 CI）。
5. **流式测试** ：可使用 WebSocket 客户端或 SSE 客户端，验证 `StreamingAgentSession` 的事件顺序和 `usage` 字段。
6. **阶段契约验证** ：在测试中断言 `stage_history`、`transition`、`TripStage` 状态，防止阶段回退或跳跃。
7. **KB/Embedding 检查** ：启用 Qdrant 后，编写集成测试验证向量写入/检索与 Rerank 排序是否符合预期。

**最佳实践**

* 新增 Agent 逻辑时，同时补充成功/失败/边界场景测试。
* 对外部调用使用 mock 或 sandbox 减少网络依赖。

---

## 9. 开发任务清单

1. **Agent**
   * 为每个阶段补全真实 prompt、工具决策与输出解析；在 `graph.py` 中引用新模块并返回结构化数据。
   * 扩展 AgentContext.extra，支持跨节点共享工具结果或召回信息。
   * 若需要新增阶段（例如 “Planning”），更新 `AgentOrchestratorGraph.stage_order`、`StageService.STAGE_SEQUENCE` 与数据库初始记录。
2. **Service**
   * 实现任务与行程的细化操作（如任务自动完成、行程冲突检测），并在 Agent 中调用。
   * 扩展 ConversationService，支持带上下文窗口的批量读取，为 prompt 构建提供便利。
   * 完善 KBService 与 EmbeddingService 的错误处理、重试和指标采集。
3. **Tool**
   * 将 Mock 工具替换为真实 API 封装：如天气、酒店、航班等；提供可配置的 API key、重试策略。
   * 建立 Tool Registry（可放在 `app/providers/tools/__init__.py`），统一注册/加载工具，便于在 LangGraph 内动态选择。
   * 为关键工具编写契约测试，确保输入输出 schema 与 Agent 预期一致。
4. **Pipeline & QA**
   * 在 orchestrator 层增加工具执行追踪（记录执行次数、耗时、异常），写入 Audit Service。
   * 构建自动化测试场景：阶段推进、任务生成、KB 检索、流式输出。
   * 编写开发文档模板，说明如何配置环境变量（LLM、Qdrant、Redis）并运行本地集成测试。

完成上述任务后，JourneyOn 智能体将具备可扩展的多阶段编排能力，并可与知识库、任务系统和外部工具紧密结合，支持完整的旅行规划与执行体验。
