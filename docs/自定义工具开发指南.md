# JourneyOn 自定义工具开发指南

## 1. 工具体系概览
JourneyOn 将外部 API、业务流程或复杂计算封装为 LangGraph 兼容的结构化工具（Structured Tool），统一由 `app/providers/tools` 目录维护。框架核心是 `StandardStructuredTool`，它基于 `langchain-core` 的 `StructuredTool` 实现，并在缺少依赖时回退到轻量自定义版本，保证离线环境也能运行。【F:app/providers/tools/standard.py†L7-L61】【F:app/providers/tools/standard.py†L61-L99】

工具的输入统一通过 Pydantic 模型校验（`StandardToolInput` 或自定义 Schema），输出为字典或可 JSON 序列化对象，方便在 Agent 内消费或写入数据库。【F:app/providers/tools/standard.py†L55-L63】【F:app/agents/base_agent.py†L27-L86】

## 2. 标准骨架说明
`StandardStructuredTool` 约定了三项基础信息：
- `name`：工具唯一标识，默认 `journeyon_standard_tool`，实际开发需在子类中覆盖；
- `description`：向模型说明工具用途；
- `args_schema`：Pydantic 模型，用于描述输入字段、类型与默认值。

在初始化阶段，若未显式传入 `func`/`coroutine`，框架自动回退至子类的 `_run` 方法，实现最少配置即可落地同步工具；如需原生异步支持，可重写 `_arun` 或在构造时提供 `coroutine`。【F:app/providers/tools/standard.py†L61-L99】

> **注意**：`StandardStructuredTool` 的轻量回退实现仅在未安装 `langchain-core` 时生效，逻辑相同但缺乏部分扩展特性，适合本地开发或最小依赖场景。【F:app/providers/tools/standard.py†L7-L52】

## 3. 新工具开发流程
1. **创建文件**：在 `app/providers/tools` 下新增 `<feature>_tool.py` 文件，并继承 `StandardStructuredTool`。
2. **定义输入 Schema**：
   ```python
   class TripWeatherInput(StandardToolInput):
       city: str = Field(..., description="需要查询天气的城市")
       trip_id: UUID
   ```
   - 简单场景可复用 `StandardToolInput`，复杂输入请自定义模型，字段描述将进入工具提示；
   - 若继承基础输入模型，记得在子类 `args_schema` 中指定新的 Schema。
3. **实现业务逻辑**：实现 `_run`（同步）或 `_arun`（异步）方法，返回字典结构，例如：
   ```python
   class TripWeatherTool(StandardStructuredTool):
       name = "trip_weather"
       description = "查询指定行程目的地的最新天气"
       args_schema = TripWeatherInput

       def _run(self, *, city: str, trip_id: UUID, **_: Any) -> dict[str, Any]:
           weather = self.weather_client.fetch(city)
           return {"trip_id": str(trip_id), "city": city, "forecast": weather}
   ```
4. **注册工具**：在对应阶段 Agent 中注入，常见方式包括：
   - 在 `__init__` 中维护 `self.tools = [TripWeatherTool()]`；
   - 或重写 `resolve_tools()`，根据上下文动态返回工具列表；
   - 对于需要跨阶段共享的工具，可在 orchestrator 层集中注册。【F:app/agents/base_agent.py†L65-L86】
5. **在 Agent 中调用**：Agent 可直接将工具实例传给 LangGraph 节点，或手动调用 `tool.ainvoke()`/`invoke()`，结果写入 `AgentRunResult.data`，确保对前端与服务层保持结构一致。【F:app/agents/graph.py†L31-L68】

## 4. 与服务层、外部依赖集成
- 使用 Service 层封装数据库操作，避免工具内直接操作 ORM，例如调用 `TripService` 写入任务或行程记录。【F:app/services/trip_service.py†L12-L166】
- 外部 API 调用建议统一放入 Provider/Client，再由工具注入依赖，方便单元测试时替换 Mock。
- 如果工具需要访问缓存或向量数据库，优先复用既有服务（如 `ConversationService`、`MemoryService`），以保持配置与连接池统一。【F:app/services/memory_service.py†L21-L200】

## 5. 调试与测试建议
- **单元测试**：针对工具 `_run/_arun` 编写独立测试，覆盖成功与异常场景；使用 pytest fixture 注入 Mock Client，提高可重复性。【F:tests/test_agent_linear_flow.py†L1-L104】
- **结构化校验**：在测试中直接调用工具实例，并断言返回结构与 `args_schema` 一致；必要时检查 `tool.description` 是否准确传达意图。
- **异步执行**：如果工具依赖协程，请在测试里使用 `asyncio.run(tool.ainvoke(...))` 或 pytest-asyncio 的 `async` 用例，确保 `_arun` 逻辑无误。
- **LangGraph 集成**：通过调用阶段 Agent 的 `run()` 或集成测试，验证工具注册后是否被 orchestrator 正确调度，结果是否写入 `AgentRunResult`。

## 6. 最佳实践与常见陷阱
- 为工具命名时保持小写 + 下划线格式，确保与 LangChain/LangGraph 命名兼容；描述应包含输入输出与副作用，帮助模型正确选择。
- 对需要共享的上下文，将结果写入 `AgentContext.extra`，避免重复调用开销。【F:app/agents/base_agent.py†L33-L63】
- 避免在工具内直接访问全局配置，优先通过依赖注入获取客户端或 service。
- 若工具涉及敏感操作（如支付、资源修改），在 `_run` 中加入幂等校验与异常处理，并在 Agent 层增加用户确认流程。
- 当工具会产生大体积结果时，可返回结构化摘要，同时将原始数据写入存储或缓存，并在返回对象中提供引用 ID。

---
通过以上步骤，即可快速在 JourneyOn 后端扩展自定义工具，并保持与现有 LangGraph 智能体编排及服务层契约的一致性。
