
# 记忆与偏好类工具设计与开发指南（更新版）

本文档在当前 JourneyOn 智能体框架基础上，细化“记忆访问”“偏好标签抽取”“偏好沉淀建议”“行程上下文同步”四类内部工具的设计要点，确保多阶段智能体能够稳定读写 mem0 记忆层并与用户画像打通。

## 共通设计基线

* **统一工具骨架** ：所有工具均应位于 `app/providers/tools` 目录并继承 `StandardStructuredTool`，复用内置的 `args_schema`、描述字段及同步/异步回退能力，保持与 LangGraph 兼容。
* **上下文契约** ：阶段 Agent 通过 `AgentContext` 传递行程 ID、用户 ID、阶段等关键信息，并以 `AgentRunResult.data` 承载结构化输出，工具落地时需确保结果字段能被阶段逻辑收集与汇总。
* **记忆服务封装** ：读写 mem0 必须通过 `MemoryService` 或其 `get_memory_service()` 单例，保证在 `MEMORY_ENABLED=false` 时安全降级，同时带上 `user_id`、`agent_id`、`run_id` 过滤以维持租户隔离。
* **画像协作** ：偏好标签与建议需通过 `tag_service` 等服务将结构化结果写入数据库，避免工具直接操作 ORM，便于审计与批量更新。
* **测试策略** ：新增工具至少补充调用级单元测试，或在 `tests/test_agent_linear_flow.py` 这类集成测试中覆盖结果写入/阶段推进路径，防止未来回归。

## 记忆访问工具（Mem0 封装）

### 功能与范围

* 为各阶段 Agent 提供统一的记忆读写接口，支持写入对话片段、查询语义记忆、更新/删除历史记录。
* 工具输出需包含 `operation`、`status`、`payload` 字段，方便前端与编排层识别具体操作与结果。

### 输入与输出设计

* 定义 `MemoryToolInput`（继承 `StandardToolInput`），包含以下字段：
  * `action`：add / search / update / delete / history
  * `messages`：写入的对话内容
  * `query`：检索关键词
  * `filters`：筛选条件（user_id、trip_id、scene 等）
  * `memory_id`：目标记忆 ID（用于更新或删除）
  * `update_mode`：新增字段，区分更新方式：
    * `"overwrite"`：重写模式，完全替换已有向量内容；
    * `"append"`：补充模式，追加内容并重算 embedding 向量；
    * 默认为 `"append"`。

### 逻辑与状态控制

* `_run` 中按 `action` 分支调用 `MemoryService` 对应方法：
  * 若为 `update`，根据 `update_mode` 选择：
    * `overwrite`：调用 `MemoryService.replace_memory()`；
    * `append`：调用 `MemoryService.update_memory()` 并触发 embedding 重算。
  * 返回 `{"operation": action, "status": "success", "payload": ...}`。
* 异常时捕获并回落为 `status="fallback"` 或 `status="disabled"`，与 `MemoryService` 的空返回语义保持一致。

### 状态与审计

* 每次写入应把 `user_id`、`agent_id`（阶段标识）、`run_id`（来自 orchestrator 的 UUID）和可选业务维度如 `trip_id`、`scene` 放入 `metadata` 或 `filters`，便于后续检索与批量清理。
* 工具在 `MEMORY_ENABLED=false` 时返回 `{"status": "disabled"}`，并记录到 `AgentRunResult.data["memory"]`。

### 接入流程

1. 在 `app/providers/tools/memory_access_tool.py` 实现工具类并注册到需要访问记忆的阶段 Agent。
2. 阶段 Agent 在调用后，将结果写入 `context.extra["memory"]` 避免重复读写，最终在 `AgentRunResult.data` 中返回供 orchestrator 汇总。

## 偏好标签抽取工具

### 功能与范围

* 聚合当前会话与历史记忆，生成用户偏好标签，并写入画像服务。
* 支持 `dry_run` 模式，仅返回候选标签而不落库。

### 数据流建议

1. 调用记忆访问工具或直接使用 `MemoryService.search`，拉取相关对话片段（`top_k` 建议 5~10）。
2. 使用 LLM/规则提炼标签，输出结构如 `[{"tag": "亲子游", "weight": 0.8, "source_trip_id": trip_id}]`。
3. 通过 `tag_service.bulk_upsert_user_tags` 写入数据库，实现去重与权重更新；`dry_run=True` 时跳过写入。

### 工具实现要点

* 输入 Schema：`trip_id`, `user_id`, `messages`（可选最新对话片段）、`dry_run`, `limit`。
* `_run` 返回：`AgentRunResult.data["profile_tags"] = {"candidates": [...], "applied": [...]}`。
* 若记忆关闭或检索为空，应输出空候选并在日志中记录。

### 测试建议

* 构造记忆 Mock 或在测试中预填充 mem0，验证标签生成逻辑；确保 `dry_run` 不触发数据库写入。

## 偏好沉淀建议工具（“下次更好”）

### 功能与范围

* 根据偏好标签、行程反馈、异常事件生成下一次规划建议，写入长期记忆或用户画像供 Pre-Trip 阶段直接复用。

### 设计要点

* 输入 Schema 包含：`trip_id`, `user_id`, `feedback_items`, `profile_tags`, `memory_refs`。
* 逻辑步骤：
  1. 合并 `feedback_items` 与记忆检索结果，提取痛点主题；
  2. 使用模板或 LLM 生成结构化建议：`{"category": "交通", "recommendation": "提前 2 小时到机场", "evidence": [...]}`；
  3. 通过记忆访问工具写入 mem0，标记 `scene="post_insight"`，并设置 `update_mode="append"` 以便长期积累。
* 工具返回：`AgentRunResult.data["next_trip_suggestions"]`。
* 可选缓存到 `context.extra` 防止重复生成。

### 容错与版本控制

* 输出包含 `generated_at`、`version` 字段，可用时间戳或 `run_id` 保证幂等。
* 当记忆层不可用时退化为基于当前对话生成建议，标记 `source="session_only"`。

## 行程上下文记忆同步工具

### 功能与范围

* 在阶段转换时同步行程关键事实、工具结果与用户决策，确保 On/Post 阶段可复用 Pre 阶段信息。

### 实现思路

1. 监听 `AgentContext.advance_stage` 或 orchestrator 阶段切换事件，准备写入 payload（`stage_from`, `stage_to`, `facts`, `tool_outputs`）。
2. 调用记忆访问工具或 `MemoryService.add_messages` 写入 mem0，`metadata={"trip_id": trip_id, "scene": "stage_sync"}`，并默认使用 `update_mode="overwrite"` 确保同步数据为最新快照。
3. 下一阶段启动时，使用相同过滤条件检索 `stage_sync` 记忆并填充 `context.extra`。

### 编排协作

* 在阶段 Agent 的 `run` 方法中，优先检查 `context.extra` 是否已有同步数据，若无则调用该工具。
* 写入结果附加到 `AgentRunResult.data["synced_context"]`，供前端与审计查看。
* 集成测试在 `tests/test_agent_linear_flow.py` 中验证阶段切换确实触发同步逻辑。

## 运维与调试

* 本地调试：使用 `docker-compose up -d postgres redis qdrant` + `uvicorn app.main:app --reload` 启动依赖。
* 可运行 `scripts/test_memories.py` 验证记忆链路是否可用。
* 日志需记录 `user_id`、`trip_id`、`run_id` 与操作结果，便于追踪。
* 每次重大更新运行 pytest 套件确保阶段推进和记忆写入逻辑稳定。

通过引入 `update_mode` 字段，本指南实现了记忆层的 **细粒度更新控制** ：支持“重写”（overwrite）与“补充”（append）两种模式，保障 JourneyOn 多阶段智能体在执行规划、沉淀偏好和跨阶段同步时的可控性与可追溯性。
