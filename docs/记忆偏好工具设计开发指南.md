# 记忆与偏好类工具设计与开发指南

本文档在当前 JourneyOn 智能体框架基础上，细化“记忆访问”“偏好标签抽取”“偏好沉淀建议”“行程上下文同步”四类内部工具的设计要点，确保多阶段智能体能够稳定读写 mem0 记忆层并与用户画像打通。

## 共通设计基线
- **统一工具骨架**：所有工具均应位于 `app/providers/tools` 目录并继承 `StandardStructuredTool`，复用内置的 `args_schema`、描述字段及同步/异步回退能力，保持与 LangGraph 兼容。【F:app/providers/tools/standard.py†L55-L99】
- **上下文契约**：阶段 Agent 通过 `AgentContext` 传递行程 ID、用户 ID、阶段等关键信息，并以 `AgentRunResult.data` 承载结构化输出，工具落地时需确保结果字段能被阶段逻辑收集与汇总。【F:app/agents/base_agent.py†L10-L86】【F:app/agents/orchestrator.py†L22-L153】
- **记忆服务封装**：读写 mem0 必须通过 `MemoryService` 或其 `get_memory_service()` 单例，保证在 `MEMORY_ENABLED=false` 时安全降级，同时带上 `user_id`、`agent_id`、`run_id` 过滤以维持租户隔离。【F:app/services/memory_service.py†L1-L212】【F:docs/记忆层功能说明.md†L3-L69】
- **画像协作**：偏好标签与建议需通过 `tag_service` 等服务将结构化结果写入数据库，避免工具直接操作 ORM，便于审计与批量更新。【F:app/services/tag_service.py†L1-L116】
- **测试策略**：新增工具至少补充调用级单元测试，或在 `tests/test_agent_linear_flow.py` 这类集成测试中覆盖结果写入/阶段推进路径，防止未来回归。【F:tests/test_agent_linear_flow.py†L1-L104】

## 记忆访问工具（Mem0 封装）
### 功能与范围
- 为各阶段 Agent 提供统一的记忆读写接口，支持写入对话片段、查询语义记忆、更新/删除历史记录。
- 工具输出需包含 `operation`、`status`、`payload` 字段，方便前端与编排层识别具体操作与结果。

### 输入与输出设计
- 建议定义独立的 `MemoryToolInput`（继承 `StandardToolInput`），包含 `action`（add/search/update/delete/history）、`messages`、`query`、`filters`、`memory_id` 等字段，借助 Pydantic 做类型校验。【F:app/providers/tools/standard.py†L55-L99】
- `_run` 中按 `action` 分支调用 `MemoryService` 对应方法，返回 `{"operation": action, "status": "success", "payload": ...}`，异常时捕获并回落为 `status="fallback"` 或 `status="disabled"`，与 `MemoryService` 的空返回语义保持一致。【F:app/services/memory_service.py†L87-L199】

### 状态与审计
- 每次写入应把 `user_id`、`agent_id`（阶段标识）、`run_id`（可来自 orchestrator 的 UUID）和可选业务维度如 `trip_id`、`scene` 放入 `metadata` 或 `filters`，便于后续检索与批量清理。【F:docs/记忆层功能说明.md†L23-L57】
- 工具在 `MEMORY_ENABLED=false` 时需要返回 `{"status": "disabled"}`，同时把原因写入 `AgentRunResult.data["memory"]`，供上层判断是否提示用户检查配置。

### 接入流程
1. 在 `app/providers/tools/memory_access_tool.py` 实现工具类并注册到需要访问记忆的阶段 Agent。
2. 阶段 Agent 在调用后，将结果写入 `context.extra["memory"]` 避免重复读写，最终在 `AgentRunResult.data` 中返回供 orchestrator 汇总。【F:app/agents/base_agent.py†L10-L53】

## 偏好标签抽取工具
### 功能与范围
- 聚合当前会话与历史记忆，生成用户偏好标签，并写入画像服务。
- 支持 `dry_run` 模式，仅返回候选标签而不落库，供产品侧确认。

### 数据流建议
1. 调用记忆访问工具或直接使用 `MemoryService.search`，拉取相关对话片段，默认 `top_k` 依据业务复杂度配置（建议 5~10）。【F:app/services/memory_service.py†L116-L137】
2. 使用 LLM/规则提炼标签，输出结构如 `[{"tag": "亲子游", "weight": 0.8, "source_trip_id": trip_id}]`。
3. 通过 `tag_service.bulk_upsert_user_tags` 写入数据库，实现去重与权重更新；`dry_run=True` 时跳过写入，仅返回候选列表。【F:app/services/tag_service.py†L79-L116】

### 工具实现要点
- 输入 Schema 应包含 `trip_id`, `user_id`, `messages`（可选最新对话片段）、`dry_run`、`limit` 等字段。
- `_run` 需在 `AgentRunResult.data["profile_tags"]` 中返回：`{"candidates": [...], "applied": [...]}`，其中 `applied` 记录成功写入的标签集合，便于前端展示与兜底策略复用。
- 若记忆关闭或检索为空，应输出空候选并在日志中记录，保持幂等。

### 测试建议
- 构造记忆 Mock 或在测试中预填充 mem0，验证标签生成逻辑；确保 `dry_run` 不触发数据库写入。

## 偏好沉淀建议工具（“下次更好”）
### 功能与范围
- 根据偏好标签、行程反馈、异常事件生成下一次规划建议，写入长期记忆或用户画像供 Pre-Trip 阶段直接复用。

### 设计要点
- 输入 Schema 建议包含 `trip_id`, `user_id`, `feedback_items`, `profile_tags`, `memory_refs`；前两者用于过滤，后者可以接受偏好标签工具的输出。
- 业务逻辑可分三步：
  1. 合并 `feedback_items` 与记忆检索结果，提取痛点主题；
  2. 使用模板或 LLM 生成结构化建议，例如 `{ "category": "交通", "recommendation": "提前 2 小时到机场", "evidence": [...] }`；
  3. 通过记忆访问工具写入 mem0，标记 `scene="post_insight"`，方便下次检索。【F:docs/记忆层功能说明.md†L50-L57】
- 工具返回的数据应写入 `AgentRunResult.data["next_trip_suggestions"]`，并可选在 `context.extra` 缓存，以防多次调用重复生成。【F:app/agents/base_agent.py†L10-L53】

### 容错与版本控制
- 输出需包含 `generated_at`、`version` 字段，可采用 `run_id` 或时间戳保证幂等。
- 当记忆层不可用时，退化为仅基于当前对话生成建议，并将 `source="session_only"` 标记在返回结果中。

## 行程上下文记忆同步工具
### 功能与范围
- 在阶段转换时同步行程关键事实、工具结果与用户决策，确保 On/Post 阶段可以复用 Pre 阶段信息。

### 实现思路
1. 监听 `AgentContext.advance_stage` 或 orchestrator 的阶段切换事件，准备写入 payload，包含 `stage_from`, `stage_to`, `facts`, `tool_outputs`。【F:app/agents/orchestrator.py†L22-L153】
2. 通过记忆访问工具或直接调用 `MemoryService.add_messages`，将同步包写入 mem0，并设置 `metadata={"trip_id": trip_id, "scene": "stage_sync"}`。【F:app/services/memory_service.py†L87-L114】
3. 在下一阶段启动时，使用相同过滤条件检索 `stage_sync` 记忆，将内容填充到 `context.extra`，供业务提示词和工具调用共享。【F:app/agents/base_agent.py†L10-L53】

### 编排协作
- 在阶段 Agent 的 `run` 方法中，优先检查 `context.extra` 是否已有同步数据，若无则调用工具；写入完成后将结果附加到 `AgentRunResult.data["synced_context"]`，供前端与审计查看。
- 集成测试可基于 `tests/test_agent_linear_flow.py` 扩展断言，确认阶段转换时确实触发同步逻辑并无异常回退。【F:tests/test_agent_linear_flow.py†L41-L104】

## 运维与调试
- 本地调试时，通过 `docker-compose up -d postgres redis qdrant` + `uvicorn app.main:app --reload` 启动依赖与 API，结合 `scripts/test_memories.py` 验证记忆链路是否可用。【F:docs/记忆层功能说明.md†L59-L69】
- 建议在工具日志中记录 `user_id`、`trip_id`、`run_id` 与操作结果，便于追踪问题。
- 重大逻辑更新后务必运行现有测试套（如 `pytest`），确保阶段推进和记忆写入流程保持稳定。【F:tests/test_agent_linear_flow.py†L41-L104】

通过上述指南，可在不依赖外部 API 的前提下，为 JourneyOn 多阶段智能体实现稳定、可审计的记忆与偏好类工具。该策略确保记忆层与用户画像协同工作，为后续规划、执行与复盘提供可靠上下文。 
