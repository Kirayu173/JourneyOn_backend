# JourneyOn 智能体具体逻辑开发指南

本文面向需要在现有 LangGraph 编排上继续实现“阶段内业务逻辑”的同学，给出代码落点、上下文对象、外部依赖与 Memory（mem0）协同的实践建议。

## 架构落点
- 调度入口：`app/agents/orchestrator.py`（Orchestrator.chat/stream）
- 主编排图：`app/agents/graph.py`（AgentOrchestratorGraph）
- 阶段 Agent：`app/agents/*_agent/graph.py`（占位子图，可替换为真实逻辑）
- 上下文对象：`app/agents/base_agent.py:AgentContext`
- 统一 LLM：`app/llm`（Ollama/智谱双实现）
- Memory：`app/services/memory_service.py`（mem0 封装）

## AgentContext 约定
常用字段：
- `trip_id, user_id, stage, message, client_ctx`
- `advance_stage`：是否满足“进入下一阶段”的意图
- 可在阶段节点内读取/写入 `context.extra` 扩展上下文（如工具输出）

## 阶段内逻辑建议
1. 明确输入输出契约：阶段节点应返回 `StageRunResult`，包含 `reply/usage/tools/tool_results` 等字段，便于统一串流/非串流返回。
2. 工具优先：将外部 API/流程封装为工具，阶段节点仅做“选择工具、整理入参、合并结果”。
3. 结果持久化：
   - 长期偏好/会话知识 → 使用 Memory（mem0）：`get_memory_service().add_messages/search/...`
   - 事务性数据 → 服务层（Trip/Task/Report 等）或数据库模型
4. RAG/检索：优先使用知识库接口 `/api/kb/search` 或 `kb_service`，必要时在阶段节点中融合结果并提示 LLM。

## Memory（mem0）协作模式
- 写入：在用户与 Agent 对话后，将关键信息以对话消息形式写入 `memories` 集合，添加 `user_id/agent_id/run_id` 与必要 metadata。
- 检索：在阶段逻辑开始前，先做基于用户的 Memory 检索，将摘要或关键信息作为系统消息注入模型。
- 删除/清理：当用户删除会话或进行隐私清理时，调用 `delete/delete_all` 配合 `user_id/run_id` 进行范围删除。

## 配置与环境
- Docker 下已启用 Memory：`MEMORY_ENABLED=true`，默认矢量存储为 Qdrant，嵌入走本机 Ollama。
- 主要环境变量：`MEMORY_COLLECTION_NAME, VECTOR_DIM, EMBEDDING_PROVIDER, OLLAMA_URL, OLLAMA_EMBED_MODEL`。

## 调试建议
- 使用 `scripts/test_memories.py` 快速验收 REST 接口是否联通（add/search/get/update/delete/history/delete_all）。
- 使用 `scripts/test_streaming.py` 验证阶段内逻辑的串流事件结构是否稳定。

## 注意事项
- Memory 层为“可选”，在 `settings.MEMORY_ENABLED=false` 时所有接口安全降级为空结果，请在阶段逻辑中做好空结果回退。
- 当调整嵌入模型时，请确保与 Qdrant 集合维度一致（默认 1024）。

