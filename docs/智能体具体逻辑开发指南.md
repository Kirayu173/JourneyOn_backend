# 智能体具体逻辑开发指南

## 1. 总览
JourneyOn 的智能体体系由 HTTP/SSE/WebSocket 三类入口驱动，统一进入 `Orchestrator` 完成阶段推理与状态管理。本文档面向开发者，说明如何在现有框架中补充真实的模型推理、工具调用与上下文管理逻辑。

## 2. 请求入口与上下文
1. **HTTP / SSE / WebSocket**：`/api/agent` 下的三个路由分别提供同步响应、SSE 流式传输与实时 WebSocket，会在收到用户消息后立即写入会话记录，并创建 `Orchestrator` 或 `StreamingAgentSession` 实例处理后续流程。【F:app/api/routes/agent.py†L32-L209】
2. **会话事件**：流式模式通过 `StreamingAgentSession` 先发送用户消息回显，再按模型增量输出来封装 `AgentEvent`，最终给出完整答案和运行元信息，便于前端构建时间线。【F:app/agents/streaming.py†L12-L94】

## 3. 编排核心
1. **AgentContext**：携带行程 ID、用户 ID、当前阶段、用户输入、客户端上下文及“是否请求推进阶段”标记，可在阶段实现中读取或扩展 `extra` 字段存储临时信息。【F:app/agents/base_agent.py†L10-L33】
2. **AgentRunResult**：各阶段需返回统一的数据结构，除了回复内容外，还需指明阶段状态、是否继续推进、下一阶段指针及自定义数据，确保 orchestrator 可以正确串联结果。【F:app/agents/base_agent.py†L36-L59】
3. **AgentOrchestratorGraph**：按照 `pre → on → post` 顺序执行阶段节点。若阶段返回 `should_proceed=True` 且提供合法 `next_stage`，则会进入下一阶段；否则在当前阶段停止，可保证流程可控。【F:app/agents/graph.py†L17-L68】
4. **Orchestrator**：负责载入行程、判断用户是否请求推进、运行阶段图，并在阶段变化时调用 `advance_stage` 更新数据库，同时将阶段历史、行程信息合并进最终响应。【F:app/agents/orchestrator.py†L22-L153】

## 4. 阶段逻辑实现步骤
1. **继承 `BaseAgent`**：在子类中声明 `stage`、`name`、`description`，覆盖 `run` 方法，利用 `context` 构造业务所需的提示词或工具请求参数。【F:app/agents/pre_agent/graph.py†L7-L33】【F:app/agents/on_agent/graph.py†L7-L33】【F:app/agents/post_agent/graph.py†L7-L28】
2. **调用外部能力**：在 `run` 内部可通过自定义服务调用 LLM、向量检索、行程数据等能力；若需要使用共享记忆，可注入 `MemoryService` 并调用 `add_messages`/`search` 等方法以读写记忆体。【F:app/services/memory_service.py†L21-L199】
3. **阶段推进策略**：利用 `context.advance_stage`（由 `Orchestrator._should_advance` 根据用户输入判断）决定是否推进；必要时可以在 `AgentRunResult` 中动态设定下一阶段或保持原地。【F:app/agents/orchestrator.py†L35-L153】
4. **工具结果封装**：如需返回额外数据，可在 `AgentRunResult.data` 写入结构化字段，并在 `Orchestrator` 汇总后由 API 输出到 `agent.stage_history` 中供前端展示。【F:app/agents/orchestrator.py†L137-L153】

## 5. 与阶段推进及持久化的协作
- **阶段状态**：当智能体返回推进请求时，`Orchestrator` 会调用 `advance_stage` 更新数据库，并在响应中返回 `transition`，需保证阶段结果与数据库状态一致。【F:app/agents/orchestrator.py†L125-L153】
- **会话持久化**：所有入口均通过 `save_message` 将用户消息写入数据库，智能体回复后可按需补充日志或调用其他服务记录工具输出。【F:app/api/routes/agent.py†L38-L117】

## 6. 测试与模拟
1. **单元/集成测试**：参考 `tests/test_agent_linear_flow.py`，通过注册用户、创建行程并多次调用 `/api/agent/chat` 验证阶段推进与状态写入逻辑，可在补充真实策略后扩展断言确保新工具或回复结构正确。【F:tests/test_agent_linear_flow.py†L12-L104】
2. **模拟外部依赖**：开发阶段可通过替换 `get_llm_client` 或注入假实现来模拟 LLM 响应，配合 `StreamingAgentSession` 验证流式行为，无需实际调用外部模型。【F:app/agents/orchestrator.py†L12-L19】【F:app/agents/streaming.py†L50-L94】

## 7. 最佳实践
- 在阶段逻辑中为关键操作添加结构化日志，便于追踪多阶段对话的上下游行为。
- 引入工具调用时，建议将请求/响应写入 `AgentRunResult.data`，并在前端呈现给用户以提升透明度。
- 启用记忆体前，确保配置正确并在测试环境开启 `MEMORY_ENABLED`，通过 `MemoryService` 接口验证写入与搜索流程。
- 更新逻辑后务必运行 `pytest` 与 `mypy app`，确保自动化测试与类型检查均通过。

