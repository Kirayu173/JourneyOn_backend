# 后端设计文档 — JourneyOn（基于 LangGraph + LangChain 的智能旅游后端）

> 目的：为前端（React Native + Expo）与智能体层提供稳定、高可用、可扩展的后端服务。
> 范围：架构、模块划分、接口规范、数据库模式、智能体编排细节、外部工具封装、部署与运维建议、测试与验收要点。

---

# 目录

1. 概要与目标
2. 总体架构与组件关系
3. 模块划分与职责
4. 数据库设计（关键表、DDL 摘要、ER 关系）
5. API 设计（详细接口规范示例）
6. 智能体层实现细节（LangGraph + LangChain 方案）
7. 向量知识库与记忆流水线（Qdrant 集成）
8. 外部服务封装（高德、天气、酒店/航班 mock）
9. 模型层抽象与调用策略（OpenAI / Ollama 等）
10. 运行流程（关键序列图／流程示意）
11. 部署与运维（Docker Compose、环境变量、备份）
12. 安全、日志、监控与测试策略
13. 开发建议、里程碑与验收标准
    附录：示例代码片段（SQLAlchemy 模型、FastAPI 路由、LangGraph 节点）

---

# 1. 概要与目标

后端目标是：

* 提供稳定的 CRUD 与业务 API（用户、行程、任务、会话、itinerary），并生成标准 OpenAPI 文档。
* 按“行程为主轴”组织数据与状态，支持行程三阶段（pre/on/post）状态流转。
* 实现伪多智能体：单一 Orchestrator（LangGraph）+ 各阶段专属 prompt/memory/toolchain。
* 提供实时/流式对话能力（WebSocket 支持流式 LLM 输出）。
* 提供知识库入库与向量检索能力（Qdrant/Chroma）。
* 易部署（Docker Compose），有日志、监控与简单CI。

约束：初期**不**直接做真实支付/出票，仅提供建议与外链/模拟流程。

---

# 2. 总体架构与组件关系

```
[Mobile App (Expo)] <--> [FastAPI REST + WebSocket] <---> [LangGraph Orchestrator / Agent Layer]
       |                              |                           |
       |                              |                           +--> Tools: HotelAPI, FlightAPI (mock)
       |                              |                           +--> Map/Geo Tool (高德)
       |                              |                           +--> Weather Tool
       |                              |
       |                              +--> DB: PostgreSQL (SQLAlchemy + Alembic)
       |                              +--> Cache: Redis (session/context)
       |                              +--> Vector Store: Qdrant / Chroma
       |                              +--> File Store: MinIO / Local
       |                              +--> LLM Providers: OpenAI / Ollama / Local
```

关键通信：

* 前端调用 REST（创建行程、获取行程等）；对话采用 WebSocket（便于流式返回）。
* LangGraph 由后端进程触发或长期驻留，和 FastAPI 通过内部函数调用或消息队列交互。

部署建议：所有服务容器化（FastAPI、Postgres、Redis、Qdrant、MinIO、LangGraph worker），使用 Docker Compose 开发、生产通过单主机或云容器服务部署。

---

# 3. 模块划分与职责

* **api/**：FastAPI 路由文件（auth, trips, agent, tasks, kb, health）。
* **db/**：SQLAlchemy ORM 模型、数据库会话、Alembic migrations。
* **agents/**：LangGraph 流程定义、各阶段 Agent 的实现（pre, on, post）、tool wrappers。
* **services/**：业务逻辑（itinerary_service、task_service、kb_service、embedding_service）。
* **providers/**：外部 API 封装（gaode_service.py、weather_service.py、hotel_service.py、flight_service.py）。
* **llm/**：LLM 适配器（统一接口封装 OpenAI/Ollama/本地模型），包括重试、限流、成本控制。
* **cache/**：Redis wrapper（会话上下文、短期 memory 缓存）。
* **storage/**：MinIO / 本地文件管理（报告、图片）。
* **utils/**：通用工具（logging、errors、schemas、validators）。

每个模块应有单元测试覆盖（pytest）。

---

# 4. 数据库设计（关键表与DDL 摘要）

采用 PostgreSQL + pgvector（如改用外部向量库可将 embedding 存在 Qdrant，仅保留 KB metadata 在 Postgres）。

## 关键表（摘要）

* `users`：用户（id, username, email, password_hash, meta, created_at）
* `trips`：行程（id, user_id, title, origin, origin_lat, origin_lng, destination, destination_lat, destination_lng, start_date, duration_days, budget, currency, current_stage, status, meta, created_at）
* `trip_stages`：阶段（trip_id, stage_name, status, assigned_agent, confirmed_at, meta）
* `itinerary_items`：日程项（trip_id, day, start_time, end_time, kind, title, location, lat, lng, details）
* `tasks`：任务（trip_id, stage, title, description, status, priority, assigned_to, due_date, meta）
* `conversations`：对话记录（trip_id, stage, role, message, message_meta, created_at）
* `kb_entries`：知识条目（id, trip_id, source, title, content, metadata, embedding_id?, created_at） — 向量体可在 Qdrant
* `user_tags`：用户偏好标签（user_id, tag, weight, source_trip_id）
* `audit_logs`：关键操作审计（user_id, trip_id, action, detail, created_at）

（在文档末附上核心 DDL 片段，便于直接建表 —— 见附录）

## ER 关系（文本版）

```
users 1---N trips
trips 1---N trip_stages
trips 1---N itinerary_items
trips 1---N tasks
trips 1---N conversations
users 1---N user_tags
kb_entries 0..1 --- trips (origin)
```

---

# 5. API 设计（详细示例）

> 命名风格：REST + JSON，返回统一 envelope `{ "code":0, "msg":"ok", "data": {...} }`。鉴权使用 Bearer JWT。

## Auth

* `POST /api/auth/register`
  请求：`{ username, email, password }`
  返回：`{ user: {...}, token: "jwt" }`

* `POST /api/auth/login`
  请求：`{ username_or_email, password }`
  返回：`{ user, token }`

## Trip & Stage

* `POST /api/trips` — 创建行程
  请求 body:

  ```json
  {
    "title": "成都周末游",
    "origin": "北京",
    "origin_lat": 39.9,
    "origin_lng": 116.4,
    "destination": "成都",
    "destination_lat": 30.67,
    "destination_lng": 104.06,
    "start_date": "2025-11-20",
    "duration_days": 3,
    "budget": 1500
  }
  ```

  返回：完整 trip 对象（包含 stages 初始化）

* `GET /api/trips/{trip_id}` — 获取行程详情
  返回：trip + stages + itinerary_items + tasks（分页）

* `PATCH /api/trips/{trip_id}/stage` — 切换阶段（body: `{ "to_stage": "on" }`）
  处理：更新 `trip_stages` 与 `trips.current_stage`，写入 `audit_logs`。

## Agent Chat（关键）

### 方案 A：REST（同步）

* `POST /api/agent/chat`
  请求：

  ```json
  {
    "trip_id": 123,
    "stage": "pre",
    "message": "帮我推荐成都的酒店，预算500元/晚",
    "client_ctx": { "lat": 30.67, "lng": 104.06 }
  }
  ```

  后端行为：

  * 验证 trip & stage
  * 构建 context（trip info + last N messages + KB retrieval）
  * 调用 Orchestrator (LangGraph) 返回 agent_reply
  * 保存两条会话记录（user, agent）
    返回：

  ```json
  { "reply": "推荐A酒店..., 来源: XXX", "tools": ["hotel_search"], "task_updates": [] }
  ```

### 方案 B：WebSocket（流式，推荐用于聊天）

* 前端建立 `ws://.../ws/agent/{trip_id}/{stage}?token=...`
* 后端支持流式发送 partial chunks（LLM streaming）并最终发送 `{"type":"done","payload":{...}}`
* 当 agent 触发 task / itinerary 修改，发送 `{"type":"action","payload":{...}}`，前端可展示确认按钮。

## Tasks

* `GET /api/trips/{trip_id}/tasks`
* `POST /api/trips/{trip_id}/tasks` — 新建 task
* `POST /api/trips/{trip_id}/tasks/{task_id}/complete`

## KB

* `GET /api/kb/search?q=...&k=5`
* `POST /api/kb/ingest` — 入库（后端 pipeline 调用 embedding 并写入 Qdrant + metadata）

## Health / Admin

* `GET /api/health` — 状态检查（DB, Redis, Qdrant, LLM ping）
* `GET /api/admin/metrics` — 基础使用统计（仅 admin）

---

# 6. 智能体层实现细节（LangGraph + LangChain）

## 概念

* **Orchestrator（LangGraph）**：表示状态流（pre → on → post），管理节点调用、memory 与工具路由。建议在后端以独立 worker 常驻进程运行或与 FastAPI 同进程（开发阶段可同进程，生产建议异进程）。
* **Agent 节点**：每阶段是一个节点（PreTripAgent、OnTripAgent、PostTripAgent）。每个节点包含：system prompt、工具集、memory config、输出 schema（PydanticOutputParser）。

## 设计要点

1. **Prompts**：为每阶段准备 system prompt 模板 + few-shot examples（示例对话） + output schema。
2. **Memory**：使用 ConversationBufferMemory (短期) + 回写到 KB（长期）策略。短期 context 存 Redis（或LangGraph memory），长期写入 Qdrant + kb_entries。
3. **工具（Tools）**：将外部API封装为 Tool 类（LangChain Tool），例如 `hotel_search_tool`, `flight_search_tool`, `map_search_tool`, `weather_tool`。Agent 可在 prompt 中调用工具并将结果纳入生成上下文或作为工具输出被LLM引用。
4. **Output Parsing**：对 Agent 生成的建议用 `PydanticOutputParser` 解析成结构化 JSON（便于前端渲染和后续自动化）。例如 PreTripAgent 输出 `{ "plans":[{...}], "tasks":[{...}] }`。
5. **错误控制与回退**：若 LLM 产生不可解析输出，返回 safe fallback message 并将该交互标记为 `needs_human_review`，记录到 `audit_logs`。

## 示例：PreTripAgent 工作流

* 输入：trip info + user message
* 流程：KB retrieval（Qdrant top-k） → 构建 messages（system + few-shots + conv history + tools outputs） → llm.generate (stream) → parse (Pydantic) → 持久化 tasks/itinerary proposals → 返回前端。
* 若含预订链接或价格，agent 需附来源与置信度。

---

# 7. 向量知识库与记忆流水线（Qdrant 集成）

## 流程

1. 对话或用户确认后，将关键文本（确认项、偏好、意见）抽取并做 embedding（使用统一 embedding provider）。
2. 将 embedding 及 metadata（user_id, trip_id, tags, source, timestamp）写入 Qdrant。
3. 查询时对当前 context 做 embedding，调用 Qdrant top-k 返回相关 snippets（结合 metadata 过滤，如 city=成都）。
4. Periodic job：对旧数据做去重/聚合，减少库膨胀。

## 设计细节

* Embedding 维度与模型固定（如 OpenAI text-embedding-3-large 1536）。
* 存储两份索引：`kb_entries`（长文本、景点介绍、FAQ）和 `user_memory`（用户确认、偏好）。
* 为 Qdrant 设置合适的 hnsw 参数与备份策略。

---

# 8. 外部服务封装（工具 API）

为外部服务实现统一的 provider 层，职责：

* 封装请求签名、限速、重试、错误归类
* 返回统一格式（dict with fields: {items:[], meta:{source, raw_response}}）
* 支持 Mock 模式（开发/演示用）

示例 provider：

* `gaode_service.search_poi(city, keyword, near_lat, near_lng, radius)`
* `weather_service.get_forecast(lat, lng, date_range)`
* `hotel_service.search(destination, check_in, nights, budget)`（若无付费 API 用 mock 或爬取公开数据）

对外API需放到 `providers/` 目录，并在 `tools/` 里包装成 LangChain Tools。

---

# 9. 模型层抽象与调用策略（LLM Adapter）

提供统一抽象 `LLMClient`，支持多后端：

* `OpenAIClient`（调用 OpenAI Chat + Embedding）
* `OllamaClient`（本地模型）
* `LocalLLMClient`（如使用 Mistral via Ollama/HTTP）

功能：

* `chat(messages, stream=False, max_tokens=...)`
* `embed(texts)`
* 统一处理超时、重试、速率限制、成本估算（用于控制调用频率）
* 可在 env 配置 fallback 顺序（OpenAI first, Ollama fallback）

---

# 10. 关键运行流程（序列示意）

## 场景：用户在 Pre-trip 阶段发起“推荐酒店”请求（同步概览）

1. 前端 POST `/api/agent/chat` (trip_id, stage=pre, message)
2. FastAPI 验证、加载 trip info & last conversations
3. 调用 `AgentOrchestrator.handle_message(trip_id, stage, message)`
4. Orchestrator：KB检索 -> 调用 `hotel_search_tool` -> 构建 messages -> 调用 LLM (stream or sync)
5. LLM 返回（或 stream chunks） -> OutputParser 解析 -> Orchestrator 写入 `conversations` 与可能的 `tasks` / `itinerary_items`
6. FastAPI 返回 agent 回复（或通过 WS 将流式内容推送给前端）

（WebSocket 流式路径则在第4步开始连接并逐步推送 chunk）

---

# 11. 部署与运维

## Docker Compose（开发）基本服务

* fastapi (uvicorn + gunicorn optional)
* postgres (15) + pgvector extension optional
* redis
* qdrant (or external vector db)
* minio
* langgraph_worker (python image)
* traefik / nginx optional for SSL

示例 `docker-compose.yml`（概要）将在附录给出。

## 环境变量（示例）

* `DATABASE_URL`, `REDIS_URL`, `QDRANT_URL`, `MINIO_*`, `OPENAI_API_KEY`, `OLLAMA_URL`, `SECRET_KEY` 等。

## 备份

* Postgres daily full dump + wal shipping optional
* Qdrant snapshot according to provider
* MinIO objects backup to S3

## 安全/运维

* HTTPS（production 使用反向代理或云托管）
* 将敏感密钥放在 CI secret / cloud secret manager
* DB access less privileged账号，开最小权限

---

# 12. 安全、日志、监控与测试

## 安全

* HTTPS everywhere, JWT expiration & refresh token
* Password hashing: bcrypt / argon2
* API rate limits per user (Redis token bucket)
* Input validation using Pydantic (防止注入)
* 最小化保存 PII（定位数据可模糊化）

## 日志与监控

* 应用日志：结构化 JSON logs（timestamp, level, module, request_id）发到 stdout（容器）并接收 log aggregator（ELK/Grafana Loki）
* 业务指标：Prometheus metrics（请求数、LLM调用数、Avg latency、error rate）
* 告警：LLM errors / DB down / high latency

## 测试

* 单元测试：pytest（services, providers, utils）
* 集成测试：使用 Testcontainers（Postgres/Redis）或本地 docker-compose 环境
* 性能测试：Locust 对关键 API 压测（尤其 agent chat 接口）
* E2E：模拟典型场景（创建行程 → pre agent → confirm → on agent）自动化脚本

---

# 13. 开发建议、里程碑与验收标准

## 里程碑（8周）

* 周1：项目骨架 + DB schema + auth
* 周2：trips CRUD + stages + tasks API
* 周3：LangGraph 初版 + PreTripAgent（可返回 mock proposals）
* 周4：PreTripAgent 调用真实 provider（天气/酒店 mock） + KB 入库 pipeline
* 周5：WebSocket 聊天 + 前端简单联调（chat basic）
* 周6：OnTripAgent 实时工具集成（map / nearby）
* 周7：PostTripAgent 报表生成与偏好抽取 + 系统测试
* 周8：部署、演示视频、文档整理

## 验收标准

* 功能：用户能创建行程并在 pre/on/post 中与 Agent 聊天，agent 能生成结构化建议。
* 稳定性：后端关键 API 正常率 > 99%（本地测试）且能在容器内运行。
* 文档：OpenAPI 文档完整，脚本可复现环境部署。
* 展示：两种 demo 场景可现场运行且录屏可用。

---

# 附录 A：关键 DDL 片段（PostgreSQL）

```sql
CREATE EXTENSION IF NOT EXISTS "pgvector";

CREATE TYPE trip_stage_enum AS ENUM ('pre','on','post');

CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  username VARCHAR(64) NOT NULL UNIQUE,
  email VARCHAR(255),
  password_hash TEXT,
  display_name VARCHAR(128),
  meta JSONB DEFAULT '{}',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE trips (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255),
  origin VARCHAR(255),
  origin_lat DOUBLE PRECISION,
  origin_lng DOUBLE PRECISION,
  destination VARCHAR(255),
  destination_lat DOUBLE PRECISION,
  destination_lng DOUBLE PRECISION,
  start_date DATE,
  duration_days INT,
  budget NUMERIC(10,2),
  currency VARCHAR(8) DEFAULT 'CNY',
  current_stage trip_stage_enum DEFAULT 'pre',
  status VARCHAR(32) DEFAULT 'active',
  meta JSONB DEFAULT '{}',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE trip_stages (
  id BIGSERIAL PRIMARY KEY,
  trip_id BIGINT NOT NULL REFERENCES trips(id) ON DELETE CASCADE,
  stage_name VARCHAR(8) NOT NULL,
  status VARCHAR(16) DEFAULT 'pending',
  assigned_agent VARCHAR(128),
  confirmed_at timestamptz,
  meta JSONB DEFAULT '{}',
  created_at timestamptz DEFAULT now(),
  UNIQUE(trip_id, stage_name)
);

CREATE TABLE conversations (
  id BIGSERIAL PRIMARY KEY,
  trip_id BIGINT NOT NULL REFERENCES trips(id) ON DELETE CASCADE,
  stage VARCHAR(8) NOT NULL,
  role VARCHAR(16) NOT NULL,
  message TEXT NOT NULL,
  message_meta JSONB DEFAULT '{}',
  created_at timestamptz DEFAULT now()
);
```

---

# 附录 B：示例代码（精简）

## SQLAlchemy 模型（片段）

```python
# db/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, Date, Float, JSON, Enum, TIMESTAMP
from sqlalchemy.orm import relationship, declarative_base
import enum

Base = declarative_base()

class TripStageEnum(str, enum.Enum):
    pre = "pre"
    on = "on"
    post = "post"

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String(64), unique=True, nullable=False)
    email = Column(String(255))
    password_hash = Column(String)
    meta = Column(JSON, default={})

class Trip(Base):
    __tablename__ = "trips"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    title = Column(String(255))
    origin = Column(String(255))
    origin_lat = Column(Float)
    origin_lng = Column(Float)
    destination = Column(String(255))
    start_date = Column(Date)
    duration_days = Column(Integer)
    budget = Column(Float)
    current_stage = Column(Enum(TripStageEnum), default=TripStageEnum.pre)
    meta = Column(JSON, default={})
    user = relationship("User", backref="trips")
```

## FastAPI 路由（agent chat 片段）

```python
# api/agent_routes.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from services.orchestrator import Orchestrator

router = APIRouter(prefix="/api/agent")

class ChatRequest(BaseModel):
    trip_id: int
    stage: str
    message: str

@router.post("/chat")
async def agent_chat(req: ChatRequest, user=Depends(get_current_user)):
    # 权限 & trip ownership 验证略
    orchestrator = Orchestrator()
    reply = await orchestrator.handle_message(req.trip_id, req.stage, req.message, user.id)
    return {"code":0, "msg":"ok", "data": reply}
```

## Orchestrator 简要伪代码

```python
class Orchestrator:
    async def handle_message(self, trip_id, stage, message, user_id):
        trip = await trip_repo.get(trip_id)
        context = await self.build_context(trip, stage, user_id)
        prompt = PROMPTS[stage]
        # call LLM via llm_client (supports streaming)
        result = await llm_client.chat(messages=[prompt, *context, {"role":"user","content":message}])
        parsed = output_parser.parse(result)
        await conversation_repo.save_user_and_agent(trip_id, stage, message, parsed)
        # apply actions e.g. create tasks, itinerary
        await self.apply_actions(parsed, trip_id)
        return parsed
```

---

# 附录 C：Docker Compose（概要）

```yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: journeyon
    volumes:
      - pgdata:/var/lib/postgresql/data
  redis:
    image: redis:7
  qdrant:
    image: qdrant/qdrant
    ports: ["6333:6333"]
  minio:
    image: minio/minio
    command: server /data
    environment:
      MINIO_ROOT_USER: minio
      MINIO_ROOT_PASSWORD: minio123
    ports:
      - "9000:9000"
  web:
    build: .
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    environment:
      DATABASE_URL: postgres://app:secret@postgres:5432/journeyon
      REDIS_URL: redis://redis:6379
      QDRANT_URL: http://qdrant:6333
    depends_on:
      - postgres
      - redis
      - qdrant
      - minio
volumes:
  pgdata:
```

---

