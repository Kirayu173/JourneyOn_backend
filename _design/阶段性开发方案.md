概览：下个阶段开发计划 (优化版)
我们将按照相同的四个冲刺阶段推进，但每个阶段的任务都已根据您的建议进行了强化和细化。

阶段一：核心业务 API 开发 (优化版) (强化模型与认证)

阶段二：打通智能体核心链路 (优化版) (引入抽象层与结构化日志)

阶段三：实现 Pre-Trip Agent (优化版) (引入结构化输出与任务管理)

阶段四：知识库(KB)与记忆集成 (优化版) (实现分区记忆与调试接口)

阶段一：核心业务 API 开发 (优化版)
目标：构建生产级的认证和数据模型，实现可扩展的 User 和 Trip 核心服务。

1. 任务：升级数据库模型 (Models)

文件修改：app/db/models.py

User 模型：

移除或修改 email 字段，确保其符合建议：email: str = Column(String(255), unique=True, index=True, nullable=False)。

确保 created_at 字段存在（已存在）。

Trip 模型：

添加智能体上下文所需字段：

preferences: dict = Column(JSON, nullable=True) (用于存储用户冷启动偏好)

agent_context: dict = Column(JSON, nullable=True) (用于存储智能体阶段性上下文)

Task 模型 (提前为阶段三优化)：

添加 priority: int = Column(Integer, default=1)。

确认 status 字段已存在（已存在：status: str = Column(String(32), default="pending")）。

2. 任务：实现健壮的用户服务 (Service)

文件创建：app/core/security.py

添加 hash_password(password) 和 verify_password(plain, hashed) (使用 passlib)。

添加 create_access_token(data: dict) 和 verify_token(token) (使用 python-jose)。

文件创建：app/services/user_service.py

get_user_by_email(db, email)

create_user(db, username, email, password)：包含哈希密码和数据库 IntegrityError (唯一性冲突) 异常处理。

authenticate_user(db, email, password)：验证用户并返回 User 对象。

3. 任务：升级认证 API (API)

文件修改：app/api/routes/auth.py

register：注入 db: Session，调用 user_service.create_user。

login：注入 db: Session，调用 user_service.authenticate_user，成功后调用 security.create_access_token 返回 Bearer token。

文件修改：app/api/deps.py

重构 get_current_user：

引入 OAuth2PasswordBearer。

依赖 token: str = Depends(oauth2_scheme)。

调用 security.verify_token 解码，并从数据库中加载真实用户。

4. 任务：实现行程服务与 API (Service & API)

文件创建：app/services/trip_service.py

封装 get_trip(db, trip_id, user_id) (确保行程归属权)。

create_trip(db, trip_data, user_id)。

get_user_trips(db, user_id)。

update_trip_stage(db, trip_id, user_id, new_stage)。

文件创建：app/api/routes/trips.py

POST /api/trips (依赖 get_current_user)

GET /api/trips (依赖 get_current_user)

GET /api/trips/{trip_id} (依赖 get_current_user)

PATCH /api/trips/{trip_id}/stage (依赖 get_current_user)

文件修改：app/main.py：注册 trips_router。

依赖添加 (requirements.txt)：passlib[bcrypt], python-jose[cryptography]

阶段二：打通智能体核心链路 (优化版)
目标：实现一个可插拔、可观测、支持动态上下文的智能体编排器 (Orchestrator)。

1. 任务：实现 LLM 抽象层

文件创建：app/llm/client.py

定义抽象基类：

Python

from abc import ABC, abstractmethod
class LLMClient(ABC):
    @abstractmethod
    async def chat(self, messages: list[dict]) -> str: ...
实现具体客户端 (使用 openai >= 1.0 语法)：

Python

from openai import AsyncOpenAI
from app.core.config import settings

class OpenAIClient(LLMClient):
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)

    async def chat(self, messages: list[dict]) -> str:
        response = await self.client.chat.completions.create(
            model="gpt-4o-mini", # 推荐模型
            messages=messages
        )
        return response.choices[0].message.content
2. 任务：实现动态提示词 (Prompts)

文件创建：app/agents/prompts.py

存放模板化的提示词：

Python

PRE_TRIP_PROMPT = """
你是一位旅行规划助手。
行程信息：从 {origin} 到 {destination}，预算 {budget}。
{context}
请根据用户最新消息开始对话。
"""
ON_TRIP_PROMPT = "..."
POST_TRIP_PROMPT = "..."
3. 任务：实现会话服务

文件创建：app/services/conversation_service.py (与原计划相同)

save_message(...)

get_history(...)

4. 任务：重构 Orchestrator (核心)

文件修改：app/agents/orchestrator.py

导入 logging, LLMClient, OpenAIClient, prompts 模块。

logger = logging.getLogger(__name__)

重构 handle_message：

Python

class Orchestrator:
    def __init__(self, db: Session, llm_client: LLMClient):
        self.db = db
        self.llm = llm_client
        self.trip_service = TripService(db) # 示例
        self.convo_service = ConversationService(db)

    async def handle_message(self, trip_id: int, stage: str, message: str, user_id: int) -> dict:
        # 0. 结构化日志
        logger.info({
            "event": "agent_chat_start",
            "user_id": user_id, "trip_id": trip_id, "stage": stage,
            "input_length": len(message)
        })

        # 1. 加载服务 (通过 __init__ 注入)
        # 2. 保存用户消息
        await self.convo_service.save_message(trip_id, stage, 'user', message)

        # 3. 加载上下文
        trip = await self.trip_service.get_trip(trip_id, user_id)
        history = await self.convo_service.get_history(trip_id, stage)
        kb_context = "..." # (阶段四实现)

        # 4. 选择并格式化 Prompt
        prompt_template = self.get_prompt_for_stage(stage)
        system_prompt = prompt_template.format(
            origin=trip.origin, destination=trip.destination, 
            budget=trip.budget, context=kb_context
        )

        # 5. 构建消息并调用 LLM
        messages = [{"role": "system", "content": system_prompt}] + history + [{"role": "user", "content": message}]
        llm_reply = await self.llm.chat(messages)

        # 6. 保存 Agent 回复
        await self.convo_service.save_message(trip_id, stage, 'agent', llm_reply)

        # 7. (阶段三实现) 解析和执行动作

        logger.info({"event": "agent_chat_finish", "trip_id": trip_id})
        return {"reply": llm_reply, ...} # 返回结构
文件修改：app/api/routes/agent.py

agent_chat 路由需注入 db: Session 和 current_user。

实例化 Orchestrator(db=db, llm_client=OpenAIClient()) 并调用。

依赖添加 (requirements.txt)：openai

阶段三：实现 Pre-Trip Agent (优化版)
目标：实现基于结构化 JSON 输出的自动任务生成，并提供模拟工具层。

1. 任务：实现任务服务与 API

文件创建：app/services/task_service.py

create_task(db, trip_id, stage, title, category, priority)

get_tasks_for_trip(db, trip_id, stage)

update_task_status(db, task_id, user_id, status) (确保任务归属)

文件创建：app/api/routes/tasks.py

GET /api/trips/{trip_id}/tasks

POST /api/trips/{trip_id}/tasks/{task_id}/complete

文件修改：app/main.py：注册 tasks_router。

2. 任务：实现模拟工具层

文件创建：app/providers/mock_tools.py

def get_mock_weather(city: str) -> dict:

def get_mock_hotels(city: str, budget: float) -> list:

3. 任务：升级 Pre-Trip Prompt

文件修改：app/agents/prompts.py

修改 PRE_TRIP_PROMPT，加入 JSON 指令：

Python

PRE_TRIP_PROMPT = """
... (前略) ...
当用户要求你 "规划行程" 或 "生成任务清单" 时，
你必须仅输出一个 JSON 数组，格式如下：
[{"title": "任务名", "category": "transport|accommodation|activity"}]
不要添加任何其他说明文字。
"""
4. 任务：升级 Orchestrator (动作解析)

文件修改：app/agents/orchestrator.py

在 handle_message 的步骤 7 (解析和执行动作) 中：

import json

如果 stage == 'pre'：

Python

try:
    # 尝试解析LLM回复为JSON
    tasks = json.loads(llm_reply)
    if isinstance(tasks, list) and all("title" in t for t in tasks):
        # 是任务清单
        task_service = TaskService(self.db)
        for task in tasks:
            await task_service.create_task(
                trip_id=trip_id, stage='pre',
                title=task.get('title'),
                category=task.get('category', 'general'),
                priority=task.get('priority', 1)
            )
        # 替换回复为用户友好的提示
        llm_reply = f"我已经为您生成了 {len(tasks)} 个准备任务，请在任务列表中查看。"
except json.JSONDecodeError:
    # 不是JSON，什么也不做，直接返回原始回复
    pass

# ... 在 return 处返回 llm_reply
阶段四：知识库(KB)与记忆集成 (优化版)
目标：实现用户隔离的向量记忆，并通过简单规则自动捕获偏好，提供调试接口。

1. 任务：实现 Embedding 服务

文件创建：app/services/embedding_service.py

封装 OpenAIClient (或 AsyncOpenAI) 的 embeddings.create 方法。

2. 任务：实现分区向量库服务

文件创建：app/services/kb_service.py

封装 QdrantClient。

COLLECTION_NAME = "journeyon_memories"

async def upsert_memory(text: str, embedding: list[float], user_id: int, trip_id: int)：

payload={"user_id": user_id, "trip_id": trip_id, "text": text}

使用 user_id 作为 payload 索引。

async def search_memory(query_embedding: list[float], user_id: int, k: int = 5)：

使用 Filter(must=[FieldCondition(key="user_id", match=MatchValue(value=user_id))])

确保 100% 的用户数据隔离。

3. 任务：实现记忆自动捕获 (Orchestrator)

文件修改：app/agents/orchestrator.py

import re

在 handle_message 保存用户消息 (步骤 2) 之后：

Python

if re.search(r"(我喜欢|我讨厌|我偏好|我只|我不)", message):
    # 触发异步记忆存储 (使用 background task)
    # 伪代码：
    # background_tasks.add_task(
    #     self.save_memory_task, message, user_id, trip_id
    # )
    pass # 暂时同步实现
    # embedding_svc = EmbeddingService()
    # kb_svc = KBService()
    # embedding = await embedding_svc.get_embedding(message)
    # await kb_svc.upsert_memory(message, embedding, user_id, trip_id)
在 handle_message 加载上下文 (步骤 3) 之前，实现 kb_context 的获取：

Python

# embedding_svc = EmbeddingService()
# kb_svc = KBService()
# query_embedding = await embedding_svc.get_embedding(message)
# memories = await kb_svc.search_memory(query_embedding, user_id)
# kb_context = "用户历史偏好：\n" + "\n".join([m.payload['text'] for m in memories])
4. 任务：实现记忆调试 API

文件创建：app/api/routes/kb.py

GET /api/kb/memories (依赖 get_current_user)

注入 db: Session，实例化 KBService。

调用 kb_service.search_memory (使用一个空的或通用的 query_embedding，并过滤 user_id)

返回该用户的所有记忆 payload。

文件修改：app/main.py：注册 kb_router。

依赖添加 (requirements.txt)：qdrant-client

优化后的依赖总结
Plaintext

# ... (现有依赖) ...

# 阶段一：Auth
passlib[bcrypt]
python-jose[cryptography]

# 阶段二：LLM
openai

# 阶段四：Vector DB
qdrant-client
运行与测试建议
环境变量：在 .env 文件中必须添加 OPENAI_API_KEY。

本地运行：docker-compose up --build 仍是最佳选择，它会自动启动所有服务 (Postgres, Redis, Qdrant)。

测试：

Auth (阶段一)：使用 Postman 测试 /register 和 /login，获取 Bearer token。

Trip (阶段一)：使用 Bearer token 测试 POST /api/trips。

Agent (阶段二)：测试 POST /api/agent/chat (stage='pre')，检查 conversations 表和控制台的结构化日志。

Task (阶段三)：发送 "帮我规划一下" 到 /chat，检查 /api/trips/{trip_id}/tasks 是否自动生成了任务。

Memory (阶段四)：发送 "我讨厌吃辣" 到 /chat，然后调用 GET /api/kb/memories 检查该偏好是否已被保存。

这个优化后的计划现在更加健壮、可维护，并为后续的 On-Trip 和 Post-Trip 阶段打下了坚实的基础。