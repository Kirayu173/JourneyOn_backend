---
# 🧭 JourneyOn 智能体开发阶段实施方案

**版本：v1.0（LangGraph线性智能体框架实现）**

**目标周期：2–3 周**
---
## 🎯 一、目标与范围

### ✅ 实施目标

* 建立 LangGraph 多智能体框架，支持顺序执行：

  **PreTripAgent → OnTripAgent → PostTripAgent**
* 实现基本上下文传递与状态控制（由用户确认推进阶段）
  （使用基于postgreSQL的检查点checkpointer）
* 将 LangGraph 编排与 FastAPI 的 `/api/agent/chat`、`/api/agent/chat/stream` 对接。
* 为每个阶段智能体留出“内部子图（Subgraph）”接口，后续接入复杂逻辑。

### 🚫 暂不包含

* 各阶段智能体内部的 prompt / 工具 / 记忆编排；
* 外部 API 调用细节（天气、酒店等）；
* 个性化偏好抽取逻辑。

---

## 🧩 二、总体架构概览

```
[用户消息]
    │
    ▼
┌─────────────────────────────┐
│  LangGraph Orchestrator     │
│   (AgentOrchestratorGraph)  │
│                             │
│  ┌────────────┐             │
│  │PreTripAgent│──用户确认──▶│
│  ├────────────┤             │
│  │OnTripAgent │──用户确认──▶│
│  ├────────────┤             │
│  │PostTripAgent│──结束──▶(Done)
│  └────────────┘             │
└─────────────────────────────┘
    │
    ▼
[FastAPI Streaming Layer (SSE / WS)]
```

> LangGraph 的主图（AgentOrchestratorGraph）管理三个阶段节点，
>
> 每个阶段节点可在后续替换为独立的内部子图（Subgraph）。

---

## 🧱 三、目录与模块组织建议

```
app/
 ├─ agents/
 │   ├─ graph.py                 # LangGraph 主流程定义 (Pre→On→Post)
 │   ├─ base_agent.py            # 基础Agent类 (统一接口)
 │   ├─ pre_agent/               # PreTripAgent子图（待设计）
 │   │   └─ graph.py
 │   ├─ on_agent/                # OnTripAgent子图（待设计）
 │   │   └─ graph.py
 │   ├─ post_agent/              # PostTripAgent子图（待设计）
 │   │   └─ graph.py
 │   └─ orchestrator.py          # Orchestrator入口，连接API层

```

---

## 🧠 四、LangGraph 主图逻辑（线性流转）

### 🧩 1. 主图定义：`AgentOrchestratorGraph`

LangGraph 主体定义：

```python
# app/agents/graph.py
from langgraph.graph import StateGraph, END
from app.agents.pre_agent.graph import PreTripAgentGraph
from app.agents.on_agent.graph import OnTripAgentGraph
from app.agents.post_agent.graph import PostTripAgentGraph

class AgentOrchestratorGraph:
    def __init__(self):
        self.graph = StateGraph()
        # 依次添加三个阶段节点
        self.graph.add_node("pre_trip", PreTripAgentGraph())
        self.graph.add_node("on_trip", OnTripAgentGraph())
        self.graph.add_node("post_trip", PostTripAgentGraph())
  
        # 定义线性流转关系
        self.graph.add_edge("pre_trip", "on_trip")
        self.graph.add_edge("on_trip", "post_trip")
        self.graph.add_edge("post_trip", END)

        self.graph.set_entry_point("pre_trip")
  
    async def run(self, context):
        result = await self.graph.run(context)
        return result
```

---

### 🧩 2. 每个阶段的占位子图（Subgraph Stub）

以 `PreTripAgent` 为例：

```python
# app/agents/pre_agent/graph.py
from langgraph.graph import StateGraph

class PreTripAgentGraph(StateGraph):
    async def run(self, context):
        # 预留未来的复杂逻辑
        # 当前仅返回提示
        return {
            "stage": "pre",
            "message": "PreTripAgent 处理完毕。等待用户确认进入下一阶段。"
        }
```

`OnTripAgent` 和 `PostTripAgent` 结构相同，输出内容不同即可。

---

### 🧩 3. 用户确认机制（阶段切换）

由 FastAPI 或 Orchestrator 控制是否推进：

```python
# app/services/stage_service.py
async def advance_stage(trip_id, to_stage):
    # 更新数据库 trips.current_stage
    # 写入 audit_logs
    return {"trip_id": trip_id, "new_stage": to_stage}
```

在 `/api/agent/chat` 路由中：

* 若用户消息为“确认进入下一阶段”，则调用 `advance_stage()`；
* OrchestratorGraph 从下一个节点开始执行。

---

### 🧩 4. Orchestrator 与 FastAPI 集成

```python
# app/agents/orchestrator.py
from app.agents.graph import AgentOrchestratorGraph

class Orchestrator:
    def __init__(self):
        self.main_graph = AgentOrchestratorGraph()

    async def handle_message(self, trip_id, stage, message, user_id):
        context = {
            "trip_id": trip_id,
            "stage": stage,
            "user_id": user_id,
            "input": message
        }
        result = await self.main_graph.run(context)
        return result
```

API 路由层：

```python
# app/api/agent_routes.py
@router.post("/chat")
async def agent_chat(req: ChatRequest, user=Depends(get_current_user)):
    orchestrator = Orchestrator()
    reply = await orchestrator.handle_message(
        trip_id=req.trip_id,
        stage=req.stage,
        message=req.message,
        user_id=user.id
    )
    return {"code": 0, "msg": "ok", "data": reply}
```

---

## 🧩 五、LangGraph 执行流程图

```
┌─────────────────────────────┐
│         Orchestrator        │
│     (AgentOrchestratorGraph)│
└──────────────┬──────────────┘
               │
               ▼
        ┌─────────────┐
        │ PreTripAgent│
        └─────────────┘
               │ 用户确认
               ▼
        ┌─────────────┐
        │ OnTripAgent │
        └─────────────┘
               │ 用户确认
               ▼
        ┌─────────────┐
        │PostTripAgent│
        └─────────────┘
               │
               ▼
            [END]
```

> 流程是严格线性的；
>
> 每个节点内部未来可替换为多节点 LangGraph 子图，

---

## 🧠 六、记忆层（mem0）集成与调试

为支持长期偏好与阶段上下文的检索，本项目集成了基于 mem0 的记忆层（向量检索 + 可选的 LLM 事实抽取/合并 + 历史追踪）。默认关闭，通过环境变量开启。

### 1) 启用方式
- `MEMORY_ENABLED=true`
- `MEMORY_INFER=false`（建议先以被动写入模式验证；随后再改为 `true` 以开启 LLM 抽取与合并）
- `MEMORY_COLLECTION_NAME=memories`
- 可选：`MEMORY_HISTORY_DB_PATH=/abs/path/history.db`

依赖：
- 向量库：Qdrant（`QDRANT_URL`/`QDRANT_API_KEY`/`VECTOR_DIM`）
- 嵌入：`EMBEDDING_PROVIDER=ollama|openai`（Ollama 需 `OLLAMA_URL` 和 `OLLAMA_EMBED_MODEL`）
- LLM（启用 INFER 时）：`LLM_PROVIDER=ollama|openai` 对应主机/API Key

### 2) 代码使用
入口封装：`app/services/memory_service.py`（惰性初始化、特性开关安全）

```python
from app.services.memory_service import get_memory_service

svc = get_memory_service()
svc.add_messages(
    messages=[{"role": "user", "content": "我喜欢露营"}],
    user_id=str(user_id),
    metadata={"trip_id": trip_id, "stage": stage},
    infer=False,
)

mems = svc.search(
    query="露营",
    top_k=10,
    filters={"user_id": str(user_id), "trip_id": trip_id},
)
```

元数据与筛选建议：
- 会话域：`user_id`（必填）、可选 `agent_id`、`run_id`
- 业务域：`trip_id`、`stage`、`source`
- 角色信息：`role`、`actor_id`（消息 `name`）

### 3) Orchestrator 检索注入（可选）
在生成提示前检索 Top-K 记忆片段，注入到 Prompt：

```python
from app.services.memory_service import get_memory_service

svc = get_memory_service()
context_mems = []
if getattr(settings, "MEMORY_ENABLED", False):
    context_mems = svc.search(
        query=message,
        top_k=8,
        filters={"user_id": str(user_id), "trip_id": trip_id},
    )
    # 拼装到提示词模板
```

### 4) 调试端点
启用后提供以下 API 方便本地验证：
- `POST /api/memories/add`
- `POST /api/memories/search` 与 `GET /api/memories/search`
- `GET /api/memories/{memory_id}`、`PUT /api/memories/{memory_id}`、`DELETE /api/memories/{memory_id}`
- `GET /api/memories/{memory_id}/history`
- `POST /api/memories/delete_all`

所有记忆 API 需要鉴权，并在 `MEMORY_ENABLED=false` 时返回 `memory_disabled`。

>
> 但当前版本仅输出静态响应 + 用户确认逻辑。

---

## 🧩 六、数据流设计

| 数据项      | 来源                | 去向            | 说明           |
| ----------- | ------------------- | --------------- | -------------- |
| `trip_id` | 前端请求            | Orchestrator    | 标识行程上下文 |
| `stage`   | trips.current_stage | AgentNode       | 控制当前阶段   |
| `message` | 用户输入            | 当前 Agent 节点 | 用于响应内容   |
| `context` | Redis Cache         | 各节点共享      | 后续可缓存记忆 |
| `result`  | AgentNode 输出      | SSE/WS Stream   | 前端实时显示   |

---

## ⚙️ 七、开发顺序与任务分配

| 顺序           | 模块                                | 内容                | 负责人       | 预计时间                |
| -------------- | ----------------------------------- | ------------------- | ------------ | ----------------------- |
| 1              | `app/agents/graph.py`             | 主图定义 + 线性流转 | Backend Lead | 1 天                    |
| 2              | `app/agents/pre_agent/graph.py`等 | 三个占位子图        | AI Engineer  | 1 天                    |
| 3              | `orchestrator.py`                 | 接入 FastAPI        | Backend Lead | 1 天                    |
| 4              | `stage_service.py`                | 阶段确认逻辑        | API Dev      | 1 天                    |
| 5              | 集成测试                            | 模拟阶段推进        | QA           | 2 天                    |
| **合计** |                                     |                     |              | **约 1 周可完成** |

---

## ✅ 八、验收标准

| 指标       | 验收条件                          |
| ---------- | --------------------------------- |
| 流程控制   | 用户从 pre→on→post 全流程可完成 |
| 输出内容   | 每个阶段返回独立响应              |
| 状态同步   | trips.current_stage 正确更新      |
| API 稳定性 | SSE / WebSocket 均可正常推送      |
| 可扩展性   | 每个阶段子图可独立扩展            |
