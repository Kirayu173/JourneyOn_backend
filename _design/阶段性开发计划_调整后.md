下一阶段开发计划（调整版 - 优先基础组件）
这个调整后的计划将智能体核心逻辑推迟到“阶段四”之后。

当前状态：阶段一（核心 Auth & Trip API）已高质量完成。

阶段二（新）：实现支撑性业务 CRUD (预计：4-5天)
目标：为 Tasks, Conversations (仅存储和读取), ItineraryItems 实现完整的 Service 层和 API 端点。这将构建起应用核心的非 AI 数据管理能力。

1. 任务：实现任务 (Task) 服务与 API

文件创建：app/services/task_service.py

create_task(db, trip_id, stage, title, description, priority, assigned_to, due_date, meta)

get_tasks_for_trip(db, trip_id, user_id, stage=None) (确保行程归属权)

update_task_status(db, task_id, user_id, status) (确保任务归属权)

delete_task(db, task_id, user_id) (可选)

文件创建：app/schemas/task_schemas.py
 
定义 TaskCreate, TaskUpdate, TaskResponse 等 Pydantic 模型。

文件创建：app/api/routes/tasks.py

POST /api/trips/{trip_id}/tasks (依赖 get_current_user)

GET /api/trips/{trip_id}/tasks (依赖 get_current_user, 可选 stage 过滤)

PATCH /api/trips/{trip_id}/tasks/{task_id} (依赖 get_current_user, 用于更新状态如 'done')

DELETE /api/trips/{trip_id}/tasks/{task_id} (可选, 依赖 get_current_user)

文件修改：app/main.py：注册 tasks_router。

2. 任务：实现对话 (Conversation) 存储服务与 API

文件创建：app/services/conversation_service.py (如果尚未创建)

save_message(db, trip_id, stage, role, message, message_meta)

get_history(db, trip_id, user_id, stage, limit=20) (确保行程归属权)

文件创建：app/schemas/conversation_schemas.py

定义 ConversationResponse Pydantic 模型。

文件创建：app/api/routes/conversations.py

GET /api/trips/{trip_id}/conversations (依赖 get_current_user, 需要 stage 查询参数)

文件修改：app/main.py：注册 conversations_router。

注意：此阶段 不 实现 /api/agent/chat 中的 save_message 调用，只提供读取历史记录的接口。

3. 任务：实现行程项 (ItineraryItem) 服务与 API

文件创建：app/services/itinerary_service.py

create_itinerary_item(db, trip_id, user_id, item_data) (确保行程归属权)

get_itinerary_items_for_trip(db, trip_id, user_id, day=None) (确保行程归属权)

update_itinerary_item(db, item_id, user_id, item_data) (确保归属权)

delete_itinerary_item(db, item_id, user_id) (确保归属权)

文件创建：app/schemas/itinerary_schemas.py

定义 ItineraryItemCreate, ItineraryItemUpdate, ItineraryItemResponse 等 Pydantic 模型。

文件创建：app/api/routes/itinerary_items.py

POST /api/trips/{trip_id}/itinerary (依赖 get_current_user)

GET /api/trips/{trip_id}/itinerary (依赖 get_current_user, 可选 day 过滤)

PATCH /api/trips/{trip_id}/itinerary/{item_id} (依赖 get_current_user)

DELETE /api/trips/{trip_id}/itinerary/{item_id} (依赖 get_current_user)

文件修改：app/main.py：注册 itinerary_items_router。

阶段三（新）：实现 Mock 工具与 Agent Stubs (预计：2-3天)
目标：提供 /api/agent/chat 端点的 模拟 响应，并创建模拟的外部服务调用（天气、酒店等）。这允许前端在没有真实 LLM 的情况下也能对接聊天接口和可能的工具调用流程。

1. 任务：实现模拟工具层 (Providers)

文件创建：app/providers/mock_tools.py (或分拆到 weather_mock.py, hotel_mock.py 等)

def get_mock_weather(city: str) -> dict: 返回固定的天气数据。

def search_mock_hotels(city: str, budget: float | None = None) -> list[dict]: 返回固定的酒店列表。

def search_mock_flights(...) -> list[dict]: 返回固定的航班信息。

def search_mock_pois(...) -> list[dict]: 返回固定的兴趣点信息。

2. 任务：更新 Agent API 和 Orchestrator Stubs

文件修改：app/api/routes/agent.py

确保 /chat 端点仍然存在，但其调用的 Orchestrator 将是返回 mock 数据的版本。

注入 db: Session 和 user: User = Depends(get_current_user) 以便访问行程信息。

文件修改：app/agents/orchestrator.py

移除 async (如果之前添加了)。

修改 handle_message 方法：

接收 db: Session 作为 __init__ 参数。

在 handle_message 内部：

调用 get_trip(db, trip_id, user_id) 验证行程。

不调用 LLM。

根据 stage 和 message 中的简单关键词 (例如，如果 stage=='pre' 且 message 包含 "酒店"，则调用 search_mock_hotels) 返回固定/模拟的 JSON 响应，模拟 LLM 的回复和可能的工具调用结果或任务更新。

不调用 conversation_service.save_message (因为没有真实的 Agent 回复)。

添加 logger.info 表明这是一个 stub 响应。

示例 handle_message (stub 逻辑)：

Python

import logging
from app.providers import mock_tools # 假设导入了 mock 工具
# ... (其他导入)

logger = logging.getLogger(__name__)

class Orchestrator:
    def __init__(self, db: Session):
        self.db = db

    def handle_message(self, trip_id: int, stage: str, message: str, user_id: int) -> Dict[str, Any]:
        logger.info(
            {"event": "agent_chat_stub", "trip_id": trip_id, "stage": stage}
        )
        # 验证行程 (可选但推荐)
        trip = get_trip(self.db, trip_id=trip_id, user_id=user_id)
        if not trip:
             return {"reply": "[stub] Error: Trip not found.", "tools": [], "task_updates": []}

        reply_text = f"[stub] Received: '{message}' for trip {trip_id} in stage '{stage}'."
        tools_called = []
        tasks = []

        # 非常简单的基于关键词的模拟逻辑
        if stage == "pre" and "酒店" in message:
            hotels = mock_tools.search_mock_hotels(trip.destination or "Unknown", trip.budget)
            reply_text += f"\n建议酒店: {hotels}"
            tools_called.append("hotel_search_mock")
        elif stage == "pre" and ("规划" in message or "任务" in message):
            tasks = [
                {"title": "[mock] 预订机票", "category": "transport", "priority": 1},
                {"title": "[mock] 预订酒店", "category": "accommodation", "priority": 1},
            ]
            reply_text += "\n已生成模拟任务清单。"
            # 注意：这里不实际创建任务到数据库，只在响应中模拟

        return {
            "reply": reply_text,
            "tools": tools_called,
            "task_updates": tasks, # 模拟任务更新信息
            "source": "orchestrator_stub_v2",
        }

后续阶段（延后执行）
阶段四（原阶段二&三）：实现 LLM Client, 真实 Orchestrator 逻辑（调用 LLM, 解析 JSON 任务并存入 DB）。

阶段五（原阶段四）：实现 Embedding 服务, Qdrant 服务, Orchestrator 集成记忆（存储与检索）。

验收标准（完成新阶段三后）
可以通过 API 创建、读取、更新、删除 Tasks。

可以通过 API 读取指定行程和阶段的 Conversations 历史记录。

可以通过 API 创建、读取、更新、删除 ItineraryItems。

调用 POST /api/agent/chat 时：

不需要 OpenAI API Key。

能根据简单的关键词（如“酒店”、“任务”）返回不同的、固定的模拟响应。

数据库 conversations 表不会增加 Agent 的回复记录（但用户消息可以考虑保存，取决于 agent_chat 端点设计）。

这个调整后的计划优先构建了应用的核心数据骨架和基础 API，并将 AI 部分的复杂性推迟，更符合 MVP 快速迭代和前后端并行开发的需要。