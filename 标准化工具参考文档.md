# StructuredTool 标准化工具中文文档

基于 [LangChain官方文档](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.structured.StructuredTool.html) 整理

## 概述

`StructuredTool` 是 LangChain 框架中用于定义支持多输入工具的核心类，继承自 `BaseTool`，实现了 `Runnable` 接口。它允许开发者创建可以处理多个输入的工具，通过 Pydantic 模型定义输入结构，确保输入验证和类型安全。

## 类定义

```python
class langchain_core.tools.structured.StructuredTool
```

**继承关系**：`BaseTool` → `StructuredTool`

## 初始化参数

### 必需参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `args_schema` | `Type[BaseModel]` | 无 | **必需** - 输入参数的 Pydantic 模型，定义输入结构和验证规则 |
| `name` | `str` | 无 | **必需** - 工具的唯一标识符 |
| `description` | `str` | `''` | **必需** - 工具描述，指导模型如何/何时使用，可包含少样本示例 |

### 可选参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `func` | `Callable[..., Any]` | `None` | 同步执行函数 |
| `coroutine` | `Callable[..., Awaitable[Any]]` | `None` | 异步执行函数，优先于 `func` |
| `return_direct` | `bool` | `False` | 是否直接返回工具输出（True 时代理执行器停止循环） |
| `handle_tool_error` | `bool\|str\|Callable[[ToolException], str]` | `False` | 处理 `ToolException` 的方式 |
| `handle_validation_error` | `bool\|str\|Callable[[ValidationError], str]` | `False` | 处理 `ValidationError` 的方式 |
| `metadata` | `Dict[str, Any]` | `None` | 传递给回调的元数据 |
| `tags` | `List[str]` | `None` | 传递给回调的标签，用于分类 |
| `verbose` | `bool` | `False` | 是否记录工具执行进度 |
| `response_format` | `Literal['content', 'content_and_artifact']` | `'content'` | 工具响应格式 |

### 已废弃参数

| 参数 | 废弃版本 | 替代方案 |
|------|----------|----------|
| `callback_manager` | 0.1.7 | 使用 `callbacks` |

## 核心方法

### `from_function` 类方法

```python
@classmethod
def from_function(
    func: Callable | None = None,
    coroutine: Callable[[...], Awaitable[Any]] | None = None,
    name: str | None = None,
    description: str | None = None,
    return_direct: bool = False,
    args_schema: type[BaseModel] | dict[str, Any] | None = None,
    infer_schema: bool = True,
    response_format: Literal['content', 'content_and_artifact'] = 'content',
    parse_docstring: bool = False,
    error_on_invalid_docstring: bool = False,
    **kwargs: Any,
) → StructuredTool
```

从给定函数创建工具的便捷方法。

**参数说明**：
- `func`：用于创建工具的同步函数
- `coroutine`：异步函数版本
- `name`：工具名称（默认使用函数名）
- `description`：工具描述（默认使用函数文档字符串）
- `infer_schema`：是否从函数签名推断模式（默认 True）
- `parse_docstring`：是否从 Google 风格文档字符串解析参数描述

### 执行方法

| 方法 | 描述 | 输入 | 输出 |
|------|------|------|------|
| `invoke()` | 同步调用工具，验证输入并执行 | `input: str \| dict \| ToolCall` | `Any` |
| `ainvoke()` | 异步调用工具 | `input: str \| dict \| ToolCall` | `Any` |
| `run()` | 同步运行工具，处理回调和错误 | `input: str \| dict` | `Any` |
| `arun()` | 异步运行工具 | `input: str \| dict` | `Any` |
| `batch()` | 同步批量处理多个输入 | `inputs: List[Input]` | `List[Output]` |
| `abatch()` | 异步批量处理 | `inputs: List[Input]` | `List[Output]` |

### 已废弃方法

| 方法 | 废弃版本 | 替代方案 |
|------|----------|----------|
| `__call__()` | 0.1.47 | 使用 `invoke()` |

## 关键特性

### 1. 多输入支持
通过 Pydantic 模型定义结构化输入，支持多种类型参数。

### 2. 输入验证
使用 `args_schema` 确保输入符合预期结构和类型。

### 3. 执行灵活性
支持同步和异步执行，兼容批处理和流式输出。

### 4. 错误处理
可配置的工具错误和验证错误处理机制。

### 5. 元数据管理
支持元数据和标签，便于工具分类和管理。

## 使用示例

### 基础示例

```python
from langchain_core.tools import StructuredTool
from pydantic import BaseModel, Field

class AddInput(BaseModel):
    a: int = Field(..., description="第一个数字")
    b: int = Field(..., description="第二个数字")

def add(a: int, b: int) -> int:
    """将两个数字相加"""
    return a + b

tool = StructuredTool.from_function(
    func=add,
    name="add",
    description="将两个数字相加",
    args_schema=AddInput
)

result = tool.invoke({"a": 5, "b": 3})  # 返回 8
```

### 类继承方式

```python
class MyTool(StructuredTool):
    name = "my_tool"
    description = "我的自定义工具"
    args_schema = MyInputModel
    
    def __init__(self, **kwargs):
        super().__init__(
            func=self._run,
            name=self.name,
            description=self.description,
            args_schema=self.args_schema,
            **kwargs
        )
    
    def _run(self, **kwargs) -> str:
        # 工具逻辑实现
        return "执行结果"
```

## 版本要求

- **引入版本**：langchain-core 0.2.14
- **工件支持**：需要 langchain-core >= 0.2.19

## 与相关组件的关系

### 与 BaseTool
`BaseTool` 是 `StructuredTool` 的父类，定义了工具的基本接口（如 `_run` 和 `_arun`）。

### 与 @tool 装饰器
`@tool` 装饰器可自动生成 `StructuredTool` 实例，简化工具创建，适合简单场景。

### 与代理系统
与支持多输入的代理（如 `StructuredChatAgent`）配合使用。

## 最佳实践

1. **明确描述**：提供详细的工具描述，帮助模型理解工具用途
2. **输入验证**：使用 Pydantic 模型确保输入数据的有效性
3. **错误处理**：配置适当的错误处理机制
4. **元数据管理**：使用标签和元数据便于工具管理
5. **性能考虑**：对于资源密集型操作，考虑使用异步执行

## 常见问题

### Q: 如何处理工具执行错误？
A: 使用 `handle_tool_error` 参数配置错误处理策略。

### Q: 如何定义复杂的输入结构？
A: 使用 Pydantic 模型定义嵌套的数据结构。

### Q: 工具如何与代理集成？
A: 通过代理的 `tools` 参数将工具实例传递给代理。

---

*文档基于 LangChain 官方文档整理，版本信息可能随框架更新而变化。*